Задачи на "прерывание" потока и правильную работу с InterruptedException


InterruptedException Best practices:


НЕВЕРНО:

try {
  Object o = queue.take();
} catch ( InterruptedException e ) {}


Данный код неверен, потому что он “давит” сигнал прерывания. Если этот код выполняется в thread pool’е, то на этом таске worker (который вызвал вас) должен был бы завершить исполнение задач, так как поток получил прерывание. Но этого не произойдет потому что сигнал прерывания был перехвачен вышеприведенным кодом. Как правило, это выражается в том, что после посылки kill сигнала java машине у нее остаются висеть потоки worker’ов из-за чего JVM не может завершить свою работу. В данном случае единственный выход — kill -9.
+ **генерация исключения сбрасывает флаг** и вызывающие потоки не узнают о том, что было прервано или почему

НЕВЕРНО:

try { 
  Object o = queue.take();
} catch ( InterruptedException e ) {
  throw new RuntimeException(e);
}

Следующий код так же некорректен, потому что мы “маскируем” interrupt в исключительную ситуацию другого типа. Тем самым он не дает возможности вызывающей стороне зафиксировать ситуацию прерывания.
+ **генерация исключения сбрасывает флаг** и вызывающие потоки не узнают о том, что было прервано или почему

ВЕРНО:
method() {
try {
  Object o = queue.take();
} catch ( InterruptedException e ) {
  Thread.currentThread().interrupt();
}
}

ИЛИ
method() throws InterruptedException{
  Object o = queue.take();
}

ИСКЛЮЧЕНИЕ:
**Единственная ситуация, в которой приемлемо проглотить прерывание, - это когда вы расширяете класс Thread и, следовательно, контролируете весь код выше по стеку вызовов**
Т.е. создаем прерываемую задачу, и мы точно знаем, что при прерывании мы не продолжим работу как в примере ниже

try {
            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted()) {
                queue.put(p = p.nextProbablePrime());
            }
        } catch (InterruptedException consumed) {
            /* Allow thread to exit */
        }
        

ОБ API прерывания в целом:

вызывая Thread.sleep мы вынуждены написать код реагирования на checked InterruptedException. Обработка обязательна - иначе поток не завершится. По-этому нужно либо пробросить его дальше, 
а это значит навязать всем пользователям нашего метода самим обрабатывать эту ситуацию, что дико ухудшает код. Или более нормальный способ - поймав исключения, самим прервать себя, выставив флаг в состояние прерывания через Thread.currentThread().interrupt().



 Из комментария:
 интеррупт заставит подключения или методы(wait(), sleep() и пр), которые его поддерживают, плюнуть эксепшн, который потом можно словить и спокойно выйти. То есть если поток ждет на оперциях ввода-вывода из файла, сокета или базы данных(вроде как они тоже это поддержиывают) то его можно впоне безопасно остановить. То же самое и если поток ждет на мониторе или CV.
 
 это покрывает большинство случаев когда нужно остановить поток. Если вы делаете какие-то сложные вычисления в цикле, не прибегая к никаким операциям ввода-вывода, то тогда уже придется впиливать флаг для остановки.
 
 Если задача не поддерживает interrupted механизм, то она просто повиснет
 Например - бесконечный цикл.
 
 