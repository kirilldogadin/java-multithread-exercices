Задача реализовать асбтракцию склада. (она очень близка к понятию очереди)
кол-во товара может увеличиваться, и может уменьшаться.
У склада несколько пользователей.
Есть заготовка AbstractStore

Нужно имплементировать наследника, который будет корректно работать в многопоточной среде.


Реализовать методы:
abstract public void getProduct(int productCount);
Логика:
1. Проверяем условие (!isCanGet())
Если Нельзя выполнить действие, то 
ждем (wait) иначе 

2. выполняем логику (прибавить this.productCount аругмент метода productCount )
3. вызываем notify();



Логика:
abstract public void putProduct(int productCount);

Полностью аналогична предыдущей, но только на взятие товара
(!isCanGet()) - isCanPut
логика - убавляем this.productCount

На этом примере очень важно понять такую вещь как 
Спин Лок - Spin Lock
и почему использование if - плохая практика, а while (Spin Lock) хорошая.
Добиться состояния гонки между потоками.

Эта тема освещена только в одном источнике - java Threads.
В остальных источниках и даже оф. докумнтации использование while мотивируется только внезапным пробуждением потоков , но это неверно, эта причина не так важна как состояние гонки.

Осознайте тот случай, когда после пробуждения, повторная проверка не происходит т.к условие if пройдено до засыпания потока, и оно уже изменилось после пробуждения потока.